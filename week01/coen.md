# Chapter1 동시성 소개
지나치게 병렬적(embarrassingly parallel, 과잉병렬): 손쉽게 병렬 작업들로 나눌 수 있다는 의미. 과잉 병렬에 해당할 경우 프로그램에서 더 많은 코어를 사용할 수 있게 만들어 성능을 상당히 향상할 수 있게 된다. 이때, 병렬 처리된 결과를 어떻게 결합하고 저장하느냐가 새로운 문제로 떠오르게 됨

## 동시성이 어려운 이유
- 생각대로 동작하게 하려면 일반적으로 반복 작업을 몇 번이나 해야 한다.
- 타이밍이 변경돼 기존에 발견되지 않던 버그가 발견되는 경우도 있다.

### Race Condition
- 둘 이상의 작업이 올바른 순서로 실행되지 않아 그렇게 작성되지 않아 순서 유지가 보장되지 않을 때 발생
- 대부분 데이터 레이스로 발생

```
var data int
go func() {
  data++
}()
if data == 0 {
  fmt.Printf("value is %d\n", data)
}
```

위 코드의 경우 3가지 결과가 나올 수 있는데, 다음과 같다.
1. 출력x
2. value is 0
3. value is 1

이 문제를 해결하기 위해 Sleep을 사용하는 경우가 있는데 절대 해서는 안된다!

race condition은 동시성 버그 중 가장 은밀한 유형 중 하나로, 코드가 올바르게 작동하는 것 처럼 보이지만 추후 애러가 발생할 확률이 높다.

### 원자성
무언가가 원자적이거나 원자적인 속성을 가진다 : 동작하는 컨텍스트 내에서 나누어지거나 중단되지 않는다는 것을 의미  
원자성은 정의된 scope에 따라 달라질 수 있다.  

`i++`은 완자적으로 보일 수 있지만 몇가지 연산으로 구성되어 있다.

1. i의 값을 가져온다
2. i의 값을 증가시킨다
3. i의 값을 저장한다

세 연산의 조합은 상황에 따라 원자적일수 있고, 아닐 수도 있다.

동시에 수행되는 프로세스들이 없는 컨텍스트라면 원자적, i값을 다른 고루틴들에게 노출하지 않는 고루틴의 경우도 원자적이다.

### 원자성을 신경써야 하는 이유
무언가 원자라면 암묵적으로 동시에 실행되는 컨텍스트 내에서는 안전하는 것을 의미하기 때문에 중요.

### 메모리 접근 동기화
리소스에 독점적으로 접근해야 하는 영역을 칭하는 이름이 있는데, 이를 `임계 영역`이라고 한다.

```
var data int
go func() { data++ }()
if data == 0 {
  fmt.Println("the value is 0")
} else {
  fmt.Printf("value is %d\n", data)
}
```

위 에시에는 세가지 임계영역이 있다.
1. data 변수를 증가시키는 goroutine
2. data 값이 0인지 확인하는 if 구문
3. 출력할 data 값을 가져오는 fmt.Printf구문

sync.Mutex를 사용하여 데이터 접근 동기화 시키는 방법이 있지만 좋은 방법은 아니다.  
Mutex의 Lock은 프로그램을 느려지게 만들 수 있다.  

## 데드락, 라이브락, 기아 상태
데이터 레이스를 해결하더라도 데드락, 라이브락, 기아 상태와 같은 또 다른 문제가 발생할 수 있다.

### 데드락






