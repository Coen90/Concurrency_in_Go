# Chapter1 동시성 소개
지나치게 병렬적(embarrassingly parallel, 과잉병렬): 손쉽게 병렬 작업들로 나눌 수 있다는 의미. 과잉 병렬에 해당할 경우 프로그램에서 더 많은 코어를 사용할 수 있게 만들어 성능을 상당히 향상할 수 있게 된다. 이때, 병렬 처리된 결과를 어떻게 결합하고 저장하느냐가 새로운 문제로 떠오르게 됨

## 동시성이 어려운 이유
- 생각대로 동작하게 하려면 일반적으로 반복 작업을 몇 번이나 해야 한다.
- 타이밍이 변경돼 기존에 발견되지 않던 버그가 발견되는 경우도 있다.

### Race Condition
- 둘 이상의 작업이 올바른 순서로 실행되지 않아 그렇게 작성되지 않아 순서 유지가 보장되지 않을 때 발생
- 대부분 데이터 레이스로 발생

```
var data int
go func() {
  data++
}()
if data == 0 {
  fmt.Printf("value is %d\n", data)
}
```

위 코드의 경우 3가지 결과가 나올 수 있는데, 다음과 같다.
1. 출력x
2. value is 0
3. value is 1

이 문제를 해결하기 위해 Sleep을 사용하는 경우가 있는데 절대 해서는 안된다!

race condition은 동시성 버그 중 가장 은밀한 유형 중 하나로, 코드가 올바르게 작동하는 것 처럼 보이지만 추후 애러가 발생할 확률이 높다.

### 원자성
무언가가 원자적이거나 원자적인 속성을 가진다 : 동작하는 컨텍스트 내에서 나누어지거나 중단되지 않는다는 것을 의미  
원자성은 정의된 scope에 따라 달라질 수 있다.  

`i++`은 완자적으로 보일 수 있지만 몇가지 연산으로 구성되어 있다.

1. i의 값을 가져온다
2. i의 값을 증가시킨다
3. i의 값을 저장한다

세 연산의 조합은 상황에 따라 원자적일수 있고, 아닐 수도 있다.

동시에 수행되는 프로세스들이 없는 컨텍스트라면 원자적, i값을 다른 고루틴들에게 노출하지 않는 고루틴의 경우도 원자적이다.


